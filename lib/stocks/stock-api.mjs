import {getStocksDB} from '@lib/mysql/mysql.mjs';

const ALPHA_VANTAGE_API_KEY = process.env.ALPHA_VANTAGE_API_KEY || 'demo';
const ALPHA_VANTAGE_BASE_URL = 'https://www.alphavantage.co/query';

/**
 * Fetch current stock quote from Alpha Vantage API
 */
export const fetchStockQuote = async (symbol) => {
	try {
		const url = `${ALPHA_VANTAGE_BASE_URL}?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${ALPHA_VANTAGE_API_KEY}`;
		const response = await fetch(url);
		const data = await response.json();

		if (data['Global Quote']) {
			const quote = data['Global Quote'];
			return {
				symbol: quote['01. symbol'],
				price: parseFloat(quote['05. price']),
				change: parseFloat(quote['09. change']),
				changePercent: quote['10. change percent'],
				volume: parseInt(quote['06. volume']),
				latestTradingDay: quote['07. latest trading day'],
				previousClose: parseFloat(quote['08. previous close']),
				open: parseFloat(quote['02. open']),
				high: parseFloat(quote['03. high']),
				low: parseFloat(quote['04. low'])
			};
		}

		return null;
	} catch (error) {
		console.error('Error fetching stock quote:', error);
		return null;
	}
};

/**
 * Fetch daily time series data for stock chart
 */
export const fetchStockTimeSeries = async (symbol, outputSize = 'compact') => {
	try {
		const url = `${ALPHA_VANTAGE_BASE_URL}?function=TIME_SERIES_DAILY&symbol=${symbol}&outputsize=${outputSize}&apikey=${ALPHA_VANTAGE_API_KEY}`;
		const response = await fetch(url);
		const data = await response.json();

		if (data['Time Series (Daily)']) {
			const timeSeries = data['Time Series (Daily)'];
			const prices = [];

			for (const [date, values] of Object.entries(timeSeries)) {
				prices.push({
					date,
					open: parseFloat(values['1. open']),
					high: parseFloat(values['2. high']),
					low: parseFloat(values['3. low']),
					close: parseFloat(values['4. close']),
					volume: parseInt(values['5. volume'])
				});
			}

			// Sort by date ascending
			prices.sort((a, b) => new Date(a.date) - new Date(b.date));
			return prices;
		}

		return [];
	} catch (error) {
		console.error('Error fetching time series:', error);
		return [];
	}
};

/**
 * Get stock data with caching - checks DB first, then API
 */
export const getStockData = async (symbol, forceRefresh = false) => {
	const db = getStocksDB();
	const stocksTable = db.getTable('stocks');
	const pricesTable = db.getTable('stock_prices');

	// Check if stock exists in our database
	let stock = await stocksTable.selectOne({symbol});

	// Fetch latest quote
	const quote = await fetchStockQuote(symbol);
	if (!quote) {
		throw new Error(`Unable to fetch data for symbol: ${symbol}`);
	}

	// If stock doesn't exist, create it
	if (!stock) {
		const insertData = {
			symbol: quote.symbol,
			name: quote.symbol, // We'll update this with company name later
            status: 'watching'
            // added_at and updated_at are auto-generated by database
		};
		const result = await stocksTable.insert(insertData);
		stock = await stocksTable.selectOne({id: result.insertId});
	}

	// Check cache for recent price data (within last 5 minutes)
	const cacheThreshold = new Date(Date.now() - 5 * 60 * 1000)
		.toISOString()
		.slice(0, 19)
		.replace('T', ' ');
	const cachedPrices = await pricesTable.select(
		{stock_id: stock.id},
		{orderBy: 'price_date', order: 'DESC', size: 100}
	);

	let timeSeries = [];
	const needsFetch =
		forceRefresh || !cachedPrices.length || cachedPrices[0].updated_at < cacheThreshold;

	if (needsFetch) {
		// Fetch from API
		timeSeries = await fetchStockTimeSeries(symbol);

		// Store in database
		if (timeSeries.length > 0) {
			for (const price of timeSeries) {
				const priceData = {
					stock_id: stock.id,
					price_date: price.date,
					open_price: price.open,
					high_price: price.high,
					low_price: price.low,
					close_price: price.close,
                    volume: price.volume
                    // created_at and updated_at are auto-generated by database
				};

				// Use insertUpdate to avoid duplicates
				await pricesTable.insertUpdate(priceData, priceData, priceData);
			}
		}
	} else {
		// Use cached data
		timeSeries = cachedPrices.map((p) => ({
			date: p.price_date,
			open: p.open_price,
			high: p.high_price,
			low: p.low_price,
			close: p.close_price,
			volume: p.volume
		}));
		timeSeries.reverse(); // Ascending order by date
	}

	return {
		stock,
		quote,
		timeSeries,
		fromCache: !needsFetch
	};
};

/**
 * Search for stocks by symbol or company name
 */
export const searchStocks = async (query) => {
	try {
		const url = `${ALPHA_VANTAGE_BASE_URL}?function=SYMBOL_SEARCH&keywords=${query}&apikey=${ALPHA_VANTAGE_API_KEY}`;
		const response = await fetch(url);
		const data = await response.json();

		if (data['bestMatches']) {
			return data['bestMatches'].map((match) => ({
				symbol: match['1. symbol'],
				name: match['2. name'],
				type: match['3. type'],
				region: match['4. region'],
				currency: match['8. currency']
			}));
		}

		return [];
	} catch (error) {
		console.error('Error searching stocks:', error);
		return [];
	}
};
